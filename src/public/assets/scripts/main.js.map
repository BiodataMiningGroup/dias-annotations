{"version":3,"sources":["annotations/main.js","annotations/services/images.js","annotations/services/mapAnnotations.js","annotations/services/mapImage.js","annotations/services/urlParams.js","annotations/controllers/AnnotatorController.js","annotations/controllers/CanvasController.js","annotations/controllers/ControlsController.js","annotations/controllers/MinimapController.js","annotations/factories/debounce.js","annotations/factories/map.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["/**\n * @namespace dias.annotations\n * @description The DIAS annotations module.\n */\nangular.module('dias.annotations', ['dias.api']);\n","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name images\n * @memberOf dias.annotations\n * @description Manages (pre-)loading of the images to annotate.\n */\nangular.module('dias.annotations').service('images', function (TransectImage, URL, $q) {\n\t\t\"use strict\";\n\n\t\tvar _this = this;\n\t\t// array of all image IDs of the transect\n\t\tvar imageIds = [];\n\t\t// maximum number of images to hold in buffer\n\t\tvar MAX_BUFFER_SIZE = 10;\n\t\t// buffer of already loaded images\n\t\tvar buffer = [];\n\n\t\t// the currently shown image\n\t\tthis.currentImage = undefined;\n\n\t\t/**\n\t\t * Returns the next ID of the specified image or the next ID of the \n\t\t * current image if no image was specified.\n\t\t */\n\t\tvar nextId = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tvar index = imageIds.indexOf(id);\n\t\t\treturn imageIds[(index + 1) % imageIds.length];\n\t\t};\n\n\t\t/**\n\t\t * Returns the previous ID of the specified image or the previous ID of\n\t\t * the current image if no image was specified.\n\t\t */\n\t\tvar prevId = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tvar index = imageIds.indexOf(id);\n\t\t\tvar length = imageIds.length;\n\t\t\treturn imageIds[(index - 1 + length) % length];\n\t\t};\n\n\t\t/**\n\t\t * Returns the specified image from the buffer or `undefined` if it is\n\t\t * not buffered.\n\t\t */\n\t\tvar getImage = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tfor (var i = buffer.length - 1; i >= 0; i--) {\n\t\t\t\tif (buffer[i]._id == id) return buffer[i];\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t};\n\n\t\t/**\n\t\t * Sets the specified image to as the currently shown image.\n\t\t */\n\t\tvar show = function (id) {\n\t\t\t_this.currentImage = getImage(id);\n\t\t};\n\n\t\t/**\n\t\t * Loads the specified image either from buffer or from the external \n\t\t * resource. Returns a promise that gets resolved when the image is\n\t\t * loaded.\n\t\t */\n\t\tvar fetchImage = function (id) {\n\t\t\tvar deferred = $q.defer();\n\t\t\tvar img = getImage(id);\n\n\t\t\tif (img) {\n\t\t\t\tdeferred.resolve(img);\n\t\t\t} else {\n\t\t\t\timg = document.createElement('img');\n\t\t\t\timg._id = id;\n\t\t\t\timg.onload = function () {\n\t\t\t\t\tbuffer.push(img);\n\t\t\t\t\t// control maximum buffer size\n\t\t\t\t\tif (buffer.length > MAX_BUFFER_SIZE) {\n\t\t\t\t\t\tbuffer.shift();\n\t\t\t\t\t}\n\t\t\t\t\tdeferred.resolve(img);\n\t\t\t\t};\n\t\t\t\timg.onerror = function (msg) {\n\t\t\t\t\tdeferred.reject(msg);\n\t\t\t\t};\n\t\t\t\timg.src = URL + \"/api/v1/images/\" + id + \"/file\";\n\t\t\t}\n\n\t\t\treturn deferred.promise;\n\t\t};\n\n\t\t/**\n\t\t * Initializes the service for a given transect. Returns a promise that\n\t\t * is resolved, when the service is initialized.\n\t\t */\n\t\tthis.init = function (transectId) {\n\t\t\timageIds = TransectImage.query({transect_id: transectId});\n\t\t\t\n\t\t\treturn imageIds.$promise;\n\t\t};\n\n\t\t/**\n\t\t * Show the image with the specified ID. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.show = function (id) {\n\t\t\tvar promise = fetchImage(id).then(function() {\n\t\t\t\tshow(id);\n\t\t\t});\n\n\t\t\t// wait for imageIds to be loaded\n\t\t\timageIds.$promise.then(function () {\n\t\t\t\t// pre-load previous and next images but don't display them\n\t\t\t\tfetchImage(nextId(id));\n\t\t\t\tfetchImage(prevId(id));\n\t\t\t});\n\n\t\t\treturn promise;\n\t\t};\n\n\t\t/**\n\t\t * Show the next image. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.next = function () {\n\t\t\treturn _this.show(nextId());\n\t\t};\n\n\t\t/**\n\t\t * Show the previous image. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.prev = function () {\n\t\t\treturn _this.show(prevId());\n\t\t};\n\n\t\tthis.getCurrentId = function () {\n\t\t\treturn _this.currentImage._id;\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name mapAnnotations\n * @memberOf dias.annotations\n * @description Wrapper service handling the annotations layer on the OpenLayers map\n */\nangular.module('dias.annotations').service('mapAnnotations', function (AnnotationLabel, shapes, map, images, Annotation, debounce) {\n\t\t\"use strict\";\n\n\t\tvar annotations = {};\n\n\t\tvar featureOverlay = new ol.FeatureOverlay({\n\t\t\t// style: new ol.style.Style({\n\t\t\t// \tfill: new ol.style.Fill({\n\t\t\t// \t\tcolor: 'rgba(255, 255, 255, 0.2)'\n\t\t\t// \t}),\n\t\t\t// \tstroke: new ol.style.Stroke({\n\t\t\t// \t\tcolor: '#ffcc33',\n\t\t\t// \t\twidth: 2\n\t\t\t// \t}),\n\t\t\t// \timage: new ol.style.Circle({\n\t\t\t// \t\tradius: 7,\n\t\t\t// \t\tfill: new ol.style.Fill({\n\t\t\t// \t\t\tcolor: '#ffcc33'\n\t\t\t// \t\t})\n\t\t\t// \t})\n\t\t\t// })\n\t\t});\n\n\t\tvar features = new ol.Collection();\n\n\t\tfeatureOverlay.setFeatures(features);\n\n\t\t// convert a point array to a point object\n\t\t// re-invert the y axis\n\t\tvar convertFromOLPoint = function (point) {\n\t\t\treturn {x: point[0], y: images.currentImage.height - point[1]};\n\t\t};\n\n\t\t// convert a point object to a point array\n\t\t// invert the y axis\n\t\tvar convertToOLPoint = function (point) {\n\t\t\treturn [point.x, images.currentImage.height - point.y];\n\t\t};\n\n\t\t// assembles the coordinate arrays depending on the geometry type\n\t\t// so they have a unified format\n\t\tvar getCoordinates = function (geometry) {\n\t\t\tswitch (geometry.getType()) {\n\t\t\t\tcase 'Circle':\n\t\t\t\t\t// radius is the x value of the second point of the circle\n\t\t\t\t\treturn [geometry.getCenter(), [geometry.getRadius(), 0]];\n\t\t\t\tcase 'Polygon':\n\t\t\t\t\treturn geometry.getCoordinates()[0];\n\t\t\t\tcase 'Point':\n\t\t\t\t\treturn [geometry.getCoordinates()];\n\t\t\t\tdefault:\n\t\t\t\t\treturn geometry.getCoordinates();\n\t\t\t}\n\t\t};\n\n\t\t// saves the updated geometry of an annotation feature\n\t\tvar handleGeometryChange = function (e) {\n\t\t\tvar feature = e.target;\n\t\t\tvar save = function () {\n\t\t\t\tvar coordinates = getCoordinates(feature.getGeometry());\n\t\t\t\tfeature.annotation.points = coordinates.map(convertFromOLPoint);\n\t\t\t\tfeature.annotation.$save();\n\t\t\t};\n\t\t\t// this event is rapidly fired, so wait until the firing stops\n\t\t\t// before saving the changes\n\t\t\tdebounce(save, 500, feature.annotation.id);\n\t\t};\n\n\t\tvar createFeature = function (annotation) {\n\t\t\tvar geometry;\n\t\t\tvar points = annotation.points.map(convertToOLPoint);\n\n\t\t\tswitch (annotation.shape()) {\n\t\t\t\tcase 'Point':\n\t\t\t\t\tgeometry = new ol.geom.Point(points[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Polygon':\n\t\t\t\t\t// close the polygon\n\t\t\t\t\tpoints.push(points[0]);\n\t\t\t\t\t// example: https://github.com/openlayers/ol3/blob/master/examples/geojson.js#L126\n\t\t\t\t\tgeometry = new ol.geom.Polygon([ points ]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'LineString':\n\t\t\t\t\tgeometry = new ol.geom.LineString(points);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Circle':\n\t\t\t\t\t// radius is the x value of the second point of the circle\n\t\t\t\t\tgeometry = new ol.geom.Circle(points[0], points[1][0]);\n\t\t\t}\n\n\t\t\tvar feature = new ol.Feature({ geometry: geometry });\n\t\t\tfeature.on('change', handleGeometryChange);\n\t\t\tfeature.annotation = annotation;\n\t\t\tfeatures.push(feature);\n\t\t};\n\n\t\tvar refreshAnnotations = function (e, image) {\n\t\t\t// clear features of previous image\n\t\t\tfeatures.clear();\n\n\t\t\tannotations = Annotation.query({id: image._id});\n\t\t\tannotations.$promise.then(function () {\n\t\t\t\tannotations.forEach(function (annotation) {\n\t\t\t\t\t// TODO: lazy loading when the label overview is opened?\n\t\t\t\t\t// annotation.labels = AnnotationLabel.query({annotation_id: annotation.id});\n\t\t\t\t\tannotation.shape = function () {\n\t\t\t\t\t\treturn shapes.getName(this.shape_id);\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tannotations.forEach(createFeature);\n\t\t\t});\n\t\t};\n\n\t\t// select interaction working on \"singleclick\"\n\t\tvar select = new ol.interaction.Select();\n\n\t\tvar modify = new ol.interaction.Modify({\n\t\t\tfeatures: featureOverlay.getFeatures(),\n\t\t\t// the SHIFT key must be pressed to delete vertices, so\n\t\t\t// that new vertices can be drawn at the same position\n\t\t\t// of existing vertices\n\t\t\tdeleteCondition: function(event) {\n\t\t\t\treturn ol.events.condition.shiftKeyOnly(event) && ol.events.condition.singleClick(event);\n\t\t\t}\n\t\t});\n\n\t\t// drawing interaction\n\t\tvar draw;\n\n\t\tvar handleNewFeature = function (e) {\n\t\t\tvar geometry = e.feature.getGeometry();\n\t\t\tvar coordinates = getCoordinates(geometry);\n\n\t\t\te.feature.annotation = Annotation.add({\n\t\t\t\tid: images.getCurrentId(),\n\t\t\t\tshape_id: shapes.getId(geometry.getType()),\n\t\t\t\tpoints: coordinates.map(convertFromOLPoint)\n\t\t\t});\n\t\t};\n\n\t\tthis.init = function (scope) {\n\t\t\tfeatureOverlay.setMap(map);\n\t\t\tmap.addInteraction(select);\n\t\t\tscope.$on('image.shown', refreshAnnotations);\n\t\t};\n\n\t\tthis.startDrawing = function (type) {\n\t\t\tmap.removeInteraction(select);\n\n\t\t\ttype = type || 'Point';\n\t\t\t\n\t\t\tdraw = new ol.interaction.Draw({\n\t\t\t\tfeatures: features,\n\t\t\t\ttype: type\n\t\t\t});\n\t\t\tmap.addInteraction(modify);\n\t\t\tmap.addInteraction(draw);\n\t\t\tdraw.on('drawend', handleNewFeature);\n\t\t};\n\n\t\tthis.finishDrawing = function () {\n\t\t\tmap.removeInteraction(draw);\n\t\t\tmap.removeInteraction(modify);\n\t\t\tmap.addInteraction(select);\n\t\t};\n\n\t\tthis.deleteSelected = function () {\n\t\t\tvar selectedFeatures = select.getFeatures();\n\t\t\tselectedFeatures.forEach(function (feature) {\n\t\t\t\tfeatures.remove(feature);\n\t\t\t\tfeature.annotation.$delete();\n\t\t\t});\n\t\t\tselectedFeatures.clear();\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name mapImage\n * @memberOf dias.annotations\n * @description Wrapper service handling the image layer on the OpenLayers map\n */\nangular.module('dias.annotations').service('mapImage', function (map) {\n\t\t\"use strict\";\n\t\tvar extent = [0, 0, 0, 0];\n\n\t\tvar projection = new ol.proj.Projection({\n\t\t\tcode: 'dias-image',\n\t\t\tunits: 'pixels',\n\t\t\textent: extent\n\t\t});\n\n\t\tvar imageLayer = new ol.layer.Image();\n\n\t\tthis.init = function (scope) {\n\t\t\tmap.addLayer(imageLayer);\n\n\t\t\t// refresh the image source\n\t\t\tscope.$on('image.shown', function (e, image) {\n\t\t\t\textent[2] = image.width;\n\t\t\t\textent[3] = image.height;\n\n\t\t\t\tvar zoom = scope.viewport.zoom;\n\n\t\t\t\tvar center = scope.viewport.center;\n\t\t\t\t// viewport center is still uninitialized\n\t\t\t\tif (center[0] === undefined && center[1] === undefined) {\n\t\t\t\t\tcenter = ol.extent.getCenter(extent);\n\t\t\t\t}\n\n\t\t\t\tvar imageStatic = new ol.source.ImageStatic({\n\t\t\t\t\turl: image.src,\n\t\t\t\t\tprojection: projection,\n\t\t\t\t\timageExtent: extent\n\t\t\t\t});\n\n\t\t\t\timageLayer.setSource(imageStatic);\n\n\t\t\t\tmap.setView(new ol.View({\n\t\t\t\t\tprojection: projection,\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tzoom: zoom,\n\t\t\t\t\t// allow a maximum of 4x magnification\n\t\t\t\t\tminResolution: 0.25,\n\t\t\t\t\t// restrict movement\n\t\t\t\t\textent: extent\n\t\t\t\t}));\n\n\t\t\t\t// if zoom is not initialized, fit the view to the image extent\n\t\t\t\tif (zoom === undefined) {\n\t\t\t\t\tmap.getView().fitExtent(extent, map.getSize());\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis.getExtent = function () {\n\t\t\treturn extent;\n\t\t};\n\n\t\tthis.getProjection = function () {\n\t\t\treturn projection;\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name urlParams\n * @memberOf dias.annotations\n * @description The GET parameters of the url.\n */\nangular.module('dias.annotations').service('urlParams', function () {\n\t\t\"use strict\";\n\n\t\tvar state = {};\n\n\t\t// transforms a URL parameter string like #a=1&b=2 to an object\n\t\tvar decodeState = function () {\n\t\t\tvar params = location.hash.replace('#', '')\n\t\t\t                          .split('&');\n\n\t\t\tvar state = {};\n\n\t\t\tparams.forEach(function (param) {\n\t\t\t\t// capture key-value pairs\n\t\t\t\tvar capture = param.match(/(.+)\\=(.+)/);\n\t\t\t\tif (capture && capture.length === 3) {\n\t\t\t\t\tstate[capture[1]] = decodeURIComponent(capture[2]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn state;\n\t\t};\n\n\t\t// transforms an object to a URL parameter string\n\t\tvar encodeState = function (state) {\n\t\t\tvar params = '';\n\t\t\tfor (var key in state) {\n\t\t\t\tparams += key + '=' + encodeURIComponent(state[key]) + '&';\n\t\t\t}\n\t\t\treturn params.substring(0, params.length - 1);\n\t\t};\n\n\t\tthis.pushState = function (s) {\n\t\t\tstate.slug = s;\n\t\t\thistory.pushState(state, '', state.slug + '#' + encodeState(state));\n\t\t};\n\n\t\t// sets a URL parameter and updates the history state\n\t\tthis.set = function (params) {\n\t\t\tfor (var key in params) {\n\t\t\t\tstate[key] = params[key];\n\t\t\t}\n\t\t\thistory.replaceState(state, '', state.slug + '#' + encodeState(state));\n\t\t};\n\n\t\t// returns a URL parameter\n\t\tthis.get = function (key) {\n\t\t\treturn state[key];\n\t\t};\n\n\t\tstate = history.state;\n\n\t\tif (!state) {\n\t\t\tstate = decodeState();\n\t\t}\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name AnnotatorController\n * @memberOf dias.annotations\n * @description Main controller of the Annotator application.\n */\nangular.module('dias.annotations').controller('AnnotatorController', function ($scope, $attrs, images, urlParams) {\n\t\t\"use strict\";\n\n\t\t$scope.images = images;\n\t\t$scope.imageLoading = true;\n\n\t\t// the current canvas viewport, synced with the URL parameters\n\t\t$scope.viewport = {\n\t\t\tzoom: urlParams.get('z'),\n\t\t\tcenter: [urlParams.get('x'), urlParams.get('y')]\n\t\t};\n\n\t\t// finish image loading process\n\t\tvar finishLoading = function () {\n\t\t\t$scope.imageLoading = false;\n\t\t\t$scope.$broadcast('image.shown', $scope.images.currentImage);\n\t\t};\n\n\t\t// create a new history entry\n\t\tvar pushState = function () {\n\t\t\turlParams.pushState($scope.images.currentImage._id);\n\t\t};\n\n\t\t// start image loading process\n\t\tvar startLoading = function () {\n\t\t\t$scope.imageLoading = true;\n\t\t};\n\n\t\t// load the image by id. doesn't create a new history entry by itself\n\t\tvar loadImage = function (id) {\n\t\t\tstartLoading();\n\t\t\treturn images.show(parseInt(id)).then(finishLoading);\n\t\t};\n\n\t\t// show the next image and create a new history entry\n\t\t$scope.nextImage = function () {\n\t\t\tstartLoading();\n\t\t\timages.next().then(finishLoading).then(pushState);\n\t\t};\n\n\t\t// show the previous image and create a new history entry\n\t\t$scope.prevImage = function () {\n\t\t\tstartLoading();\n\t\t\timages.prev().then(finishLoading).then(pushState);\n\t\t};\n\n\t\t// update the URL parameters of the viewport\n\t\t$scope.$on('canvas.moveend', function(e, params) {\n\t\t\t$scope.viewport.zoom = params.zoom;\n\t\t\t$scope.viewport.center[0] = Math.round(params.center[0]);\n\t\t\t$scope.viewport.center[1] = Math.round(params.center[1]);\n\t\t\turlParams.set({\n\t\t\t\tz: $scope.viewport.zoom,\n\t\t\t\tx: $scope.viewport.center[0],\n\t\t\t\ty: $scope.viewport.center[1]\n\t\t\t});\n\t\t});\n\n\t\t// listen to the browser \"back\" button\n\t\twindow.onpopstate = function(e) {\n\t\t\tvar state = e.state;\n\t\t\tif (state && state.slug !== undefined) {\n\t\t\t\tloadImage(state.slug);\n\t\t\t}\n\t\t};\n\n\t\t// initialize the images service\n\t\timages.init($attrs.transectId);\n\t\t// display the first image\n\t\tloadImage($attrs.imageId).then(pushState);\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name CanvasController\n * @memberOf dias.annotations\n * @description Main controller for the annotation canvas element\n */\nangular.module('dias.annotations').controller('CanvasController', function ($scope, mapImage, mapAnnotations, map) {\n\t\t\"use strict\";\n\n\t\t// update the URL parameters\n\t\tmap.on('moveend', function(e) {\n\t\t\tvar view = map.getView();\n\t\t\t$scope.$emit('canvas.moveend', {\n\t\t\t\tcenter: view.getCenter(),\n\t\t\t\tzoom: view.getZoom()\n\t\t\t});\n\t\t});\n\n\t\tmapImage.init($scope);\n\t\tmapAnnotations.init($scope);\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name ControlsController\n * @memberOf dias.annotations\n * @description Controller for the sidebar controls\n */\nangular.module('dias.annotations').controller('ControlsController', function ($scope, mapAnnotations, shapes) {\n\t\t\"use strict\";\n\t\tvar drawing = false;\n\n\t\t$scope.selectedShape = {};\n\n\t\t$scope.toggleDrawing = function () {\n\t\t\tif (drawing) {\n\t\t\t\tmapAnnotations.finishDrawing();\n\t\t\t\tdrawing = false;\n\t\t\t} else {\n\t\t\t\tmapAnnotations.startDrawing($scope.selectedShape.name);\n\t\t\t\tdrawing = true;\n\t\t\t}\n\t\t};\n\n\t\t$scope.shapes = shapes.getAll();\n\n\t\t$scope.deleteSelected = mapAnnotations.deleteSelected;\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name MinimapController\n * @memberOf dias.annotations\n * @description Controller for the minimap in the sidebar\n */\nangular.module('dias.annotations').controller('MinimapController', function ($scope, map, mapImage, $element) {\n\t\t\"use strict\";\n\n\t\tvar minimap = new ol.Map({\n\t\t\ttarget: 'minimap',\n\t\t\t// remove controls\n\t\t\tcontrols: [],\n\t\t\t// disable interactions\n\t\t\tinteractions: []\n\t\t});\n\t\t// get the same layers than the map\n\t\tminimap.bindTo('layergroup', map);\n\n\t\tvar featureOverlay = new ol.FeatureOverlay({\n\t\t\tmap: minimap\n\t\t});\n\n\t\tvar viewport = new ol.Feature();\n\t\tfeatureOverlay.addFeature(viewport);\n\n\t\t// refresh the view (the image size could have been changed)\n\t\t$scope.$on('image.shown', function () {\n\t\t\tminimap.setView(new ol.View({\n\t\t\t\tprojection: mapImage.getProjection(),\n\t\t\t\tcenter: ol.extent.getCenter(mapImage.getExtent()),\n\t\t\t\tzoom: 0\n\t\t\t}));\n\t\t});\n\n\t\t// move the viewport rectangle on the minimap\n\t\tvar refreshViewport = function () {\n\t\t\tvar extent = map.getView().calculateExtent(map.getSize());\n\t\t\tviewport.setGeometry(ol.geom.Polygon.fromExtent(extent));\n\t\t};\n\n\t\tmap.on('moveend', refreshViewport);\n\n\t\tvar dragViewport = function (e) {\n\t\t\tmap.getView().setCenter(e.coordinate);\n\t\t};\n\n\t\tminimap.on('pointerdrag', dragViewport);\n\n\t\t$element.on('mouseleave', function () {\n\t\t\tminimap.un('pointerdrag', dragViewport);\n\t\t});\n\n\t\t$element.on('mouseenter', function () {\n\t\t\tminimap.on('pointerdrag', dragViewport);\n\t\t});\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc factory\n * @name debounce\n * @memberOf dias.annotations\n * @description A debounce service to perform an action only when this function\n * wasn't called again in a short period of time.\n * see http://stackoverflow.com/a/13320016/1796523\n */\nangular.module('dias.annotations').factory('debounce', function ($timeout, $q) {\n\t\t\"use strict\";\n\n\t\tvar timeouts = {};\n\n\t\treturn function (func, wait, id) {\n\t\t\t// Create a deferred object that will be resolved when we need to\n\t\t\t// actually call the func\n\t\t\tvar deferred = $q.defer();\n\t\t\treturn (function() {\n\t\t\t\tvar context = this, args = arguments;\n\t\t\t\tvar later = function() {\n\t\t\t\t\ttimeouts[id] = undefined;\n\t\t\t\t\tdeferred.resolve(func.apply(context, args));\n\t\t\t\t\tdeferred = $q.defer();\n\t\t\t\t};\n\t\t\t\tif (timeouts[id]) {\n\t\t\t\t\t$timeout.cancel(timeouts[id]);\n\t\t\t\t}\n\t\t\t\ttimeouts[id] = $timeout(later, wait);\n\t\t\t\treturn deferred.promise;\n\t\t\t})();\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc factory\n * @name map\n * @memberOf dias.annotations\n * @description Wrapper factory handling OpenLayers map\n */\nangular.module('dias.annotations').factory('map', function () {\n\t\t\"use strict\";\n\n\t\tvar map = new ol.Map({\n\t\t\ttarget: 'canvas',\n\t\t\tcontrols: [\n\t\t\t\tnew ol.control.Zoom(),\n\t\t\t\tnew ol.control.ZoomToExtent(),\n\t\t\t\tnew ol.control.FullScreen(),\n\t\t\t]\n\t\t});\n\n\t\treturn map;\n\t}\n);"],"sourceRoot":"/source/"}