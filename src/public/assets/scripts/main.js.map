{"version":3,"sources":["annotations/main.js","annotations/controllers/AnnotationsController.js","annotations/controllers/AnnotatorController.js","annotations/controllers/CanvasController.js","annotations/directives/annotation.js","annotations/directives/annotationPoint.js","annotations/services/images.js","annotations/services/urlParams.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["/**\n * @namespace dias.annotations\n * @description The DIAS annotations module.\n */\nangular.module('dias.annotations', ['dias.api']);\n","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name AnnotationsController\n * @memberOf dias.annotations\n * @description Controller for managing the annotations on the SVG.\n */\nangular.module('dias.annotations').controller('AnnotationsController', function ($scope, ImageAnnotation, AnnotationLabel, AnnotationPoint, Shape) {\n\t\t\"use strict\";\n\n\t\t// $scope.shapes = {};\n\n\t\t// Shape.query(function (shapes) {\n\t\t// \tshapes.forEach(function (shape) {\n\t\t// \t\t$scope.shapes[shape.id] = shape.name;\n\t\t// \t});\n\t\t// });\n\n\t\t// $scope.annotations = {};\n\n\t\t// var refreshAnnotations = function (e, image) {\n\t\t// \t$scope.annotations = ImageAnnotation.query({image_id: image._id});\n\t\t// \t$scope.annotations.$promise.then(function () {\n\t\t// \t\t$scope.annotations.forEach(function (annotation) {\n\t\t// \t\t\tannotation.points = AnnotationPoint.query({annotation_id: annotation.id});\n\t\t// \t\t\tannotation.labels = AnnotationLabel.query({annotation_id: annotation.id});\n\t\t// \t\t\tannotation.shape = function () {\n\t\t// \t\t\t\treturn $scope.shapes[this.shape_id];\n\t\t// \t\t\t};\n\t\t// \t\t});\n\t\t// \t});\n\t\t// };\n\n\t\t// var refreshOffset = function () {\n\t\t// \tvar image = $scope.images.currentImage;\n\t\t// \tif (!image) return;\n\n\t\t// \tvar scaleX = $scope.width / image.width;\n\t\t// \tvar scaleY = $scope.height / image.height;\n\n\t\t// \tvar offsetX = ($scope.width - image.width * scaleY) / 2;\n\t\t// \tvar offsetY = ($scope.height - image.height * scaleX) / 2;\n\t\t// \toffsetX = Math.max(offsetX, 0);\n\t\t// \toffsetY = Math.max(offsetY, 0);\n\t\t\t\n\t\t// \t$scope.offsetX = offsetX;\n\t\t// \t$scope.offsetY = offsetY;\n\t\t// };\n\n\t\t// $scope.$on('image.shown', refreshAnnotations);\n\t\t// $scope.$on('image.shown', refreshOffset);\n\t\t// $scope.$watch('width', refreshOffset);\n\t\t// $scope.$watch('height', refreshOffset);\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name AnnotatorController\n * @memberOf dias.annotations\n * @description Main controller of the Annotator application.\n */\nangular.module('dias.annotations').controller('AnnotatorController', function ($scope, $attrs, images, urlParams) {\n\t\t\"use strict\";\n\n\t\t$scope.images = images;\n\t\t$scope.imageLoading = true;\n\n\t\t$scope.viewport = {\n\t\t\tzoom: urlParams.get('z'),\n\t\t\tcenter: [urlParams.get('x'), urlParams.get('y')]\n\t\t};\n\n\t\tvar finishLoading = function () {\n\t\t\t$scope.imageLoading = false;\n\t\t\tvar image = $scope.images.currentImage;\n\t\t\turlParams.pushState(image._id);\n\t\t\t$scope.$broadcast('image.shown', image);\n\t\t};\n\n\t\tvar startLoading = function () {\n\t\t\t$scope.imageLoading = true;\n\t\t};\n\n\t\tvar showImage = function (id) {\n\t\t\timages.show(parseInt(id)).then(finishLoading);\n\t\t};\n\n\t\t$scope.nextImage = function () {\n\t\t\tstartLoading();\n\t\t\timages.next().then(finishLoading);\n\t\t};\n\n\t\t$scope.prevImage = function () {\n\t\t\tstartLoading();\n\t\t\timages.prev().then(finishLoading);\n\t\t};\n\n\t\t$scope.$on('canvas.moveend', function(e, params) {\n\t\t\t$scope.viewport.zoom = params.zoom;\n\t\t\t$scope.viewport.center[0] = Math.round(params.center[0]);\n\t\t\t$scope.viewport.center[1] = Math.round(params.center[1]);\n\t\t\turlParams.set({\n\t\t\t\tz: $scope.viewport.zoom,\n\t\t\t\tx: $scope.viewport.center[0],\n\t\t\t\ty: $scope.viewport.center[1]\n\t\t\t});\n\t\t});\n\n\t\timages.init($attrs.transectId);\n\t\tshowImage($attrs.imageId);\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name CanvasController\n * @memberOf dias.annotations\n * @description Main controller for the annotation canvas element\n */\nangular.module('dias.annotations').controller('CanvasController', function ($scope) {\n\t\t\"use strict\";\n\n\t\tvar extent = [0, 0, 0, 0];\n\n\t\tvar projection = new ol.proj.Projection({\n\t\t\tcode: 'dias-image',\n\t\t\tunits: 'pixels',\n\t\t\textent: extent\n\t\t});\n\n\t\tvar imageLayer = new ol.layer.Image();\n\n\t\tvar map = new ol.Map({\n\t\t\ttarget: 'canvas',\n\t\t\tlayers: [imageLayer],\n\t\t});\n\n\t\tmap.on('moveend', function(e) {\n\t\t\tvar view = map.getView();\n\t\t\t$scope.$emit('canvas.moveend', {\n\t\t\t\tcenter: view.getCenter(),\n\t\t\t\tzoom: view.getZoom()\n\t\t\t});\n\t\t});\n\n\t\t$scope.$on('image.shown', function (e, image) {\n\t\t\textent[2] = image.width;\n\t\t\textent[3] = image.height;\n\n\t\t\tvar zoom = $scope.viewport.zoom;\n\n\t\t\tvar center = $scope.viewport.center;\n\t\t\t// viewport center is still uninitialized\n\t\t\tif (center[0] === undefined && center[1] === undefined) {\n\t\t\t\tcenter = ol.extent.getCenter(extent);\n\t\t\t}\n\n\t\t\tvar imageStatic = new ol.source.ImageStatic({\n\t\t\t\turl: image.src,\n\t\t\t\tprojection: projection,\n\t\t\t\timageExtent: extent\n\t\t\t});\n\n\t\t\timageLayer.setSource(imageStatic);\n\n\t\t\tmap.setView(new ol.View({\n\t\t\t\tprojection: projection,\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\t// allow a maximum of 4x magnification\n\t\t\t\tminResolution: 0.25,\n\t\t\t\t// restrict movement\n\t\t\t\textent: extent\n\t\t\t}));\n\n\t\t\t// if zoom is not initialized, fit the view to the image extent\n\t\t\tif (zoom === undefined) {\n\t\t\t\tmap.getView().fitExtent(extent, map.getSize());\n\t\t\t}\n\t\t});\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc directive\n * @name annotation\n * @memberOf dias.annotations\n * @description Directive to display an annotation on the SVG.\n */\nangular.module('dias.annotations').directive('annotation', function () {\n\treturn {\n\t\trestrict: 'A',\n\t\t// template: '<polygon data-ng-attr-points=\"{{ points }}\" />',\n\t\tcontroller: function ($scope) {\n\t\t\t$scope.shape = $scope.shapes[$scope.annotation.shape_id];\n\n\t\t\t$scope.points = '';\n\n\t\t\t$scope.annotation.points.$promise.then(function (points) {\n\t\t\t\tpoints.forEach(function (point) {\n\t\t\t\t\t$scope.points += point.x + ',' + point.y + ' ';\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n});","/**\n * @namespace dias.annotations\n * @ngdoc directive\n * @name annotationPoint\n * @memberOf dias.annotations\n * @description Directive to display an annotationPoint on the SVG.\n */\nangular.module('dias.annotations').directive('annotationPoint', function () {\n\treturn {\n\t\trestrict: 'A',\n\t\ttemplate: '<use xlink:href=\"#marker\" data-ng-attr-x=\"{{ point.x }}\" data-ng-attr-y=\"{{ point.y }}\" data-ng-if=\"point\" />',\n\t\treplace: true,\n\t\tcontroller: function ($scope) {\n\t\t\t$scope.annotation.points.$promise.then(function (points) {\n\t\t\t\t$scope.point = $scope.annotation.points[0];\n\t\t\t});\n\t\t}\n\t};\n});","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name images\n * @memberOf dias.annotations\n * @description Manages (pre-)loading of the images to annotate.\n */\nangular.module('dias.annotations').service('images', function (TransectImage, URL, $q) {\n\t\t\"use strict\";\n\n\t\tvar _this = this;\n\t\t// array of all image IDs of the transect\n\t\tvar imageIds = [];\n\t\t// maximum number of images to hold in buffer\n\t\tvar MAX_BUFFER_SIZE = 10;\n\t\t// buffer of already loaded images\n\t\tvar buffer = [];\n\n\t\t// the currently shown image\n\t\tthis.currentImage = undefined;\n\n\t\t/**\n\t\t * Returns the next ID of the specified image or the next ID of the \n\t\t * current image if no image was specified.\n\t\t */\n\t\tvar nextId = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tvar index = imageIds.indexOf(id);\n\t\t\treturn imageIds[(index + 1) % imageIds.length];\n\t\t};\n\n\t\t/**\n\t\t * Returns the previous ID of the specified image or the previous ID of\n\t\t * the current image if no image was specified.\n\t\t */\n\t\tvar prevId = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tvar index = imageIds.indexOf(id);\n\t\t\tvar length = imageIds.length;\n\t\t\treturn imageIds[(index - 1 + length) % length];\n\t\t};\n\n\t\t/**\n\t\t * Returns the specified image from the buffer or `undefined` if it is\n\t\t * not buffered.\n\t\t */\n\t\tvar getImage = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tfor (var i = buffer.length - 1; i >= 0; i--) {\n\t\t\t\tif (buffer[i]._id == id) return buffer[i];\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t};\n\n\t\t/**\n\t\t * Sets the specified image to as the currently shown image.\n\t\t */\n\t\tvar show = function (id) {\n\t\t\t_this.currentImage = getImage(id);\n\t\t};\n\n\t\t/**\n\t\t * Loads the specified image either from buffer or from the external \n\t\t * resource. Returns a promise that gets resolved when the image is\n\t\t * loaded.\n\t\t */\n\t\tvar fetchImage = function (id) {\n\t\t\tvar deferred = $q.defer();\n\t\t\tvar img = getImage(id);\n\n\t\t\tif (img) {\n\t\t\t\tdeferred.resolve(img);\n\t\t\t} else {\n\t\t\t\timg = document.createElement('img');\n\t\t\t\timg._id = id;\n\t\t\t\timg.onload = function () {\n\t\t\t\t\tbuffer.push(img);\n\t\t\t\t\t// control maximum buffer size\n\t\t\t\t\tif (buffer.length > MAX_BUFFER_SIZE) {\n\t\t\t\t\t\tbuffer.shift();\n\t\t\t\t\t}\n\t\t\t\t\tdeferred.resolve(img);\n\t\t\t\t};\n\t\t\t\timg.onerror = function (msg) {\n\t\t\t\t\tdeferred.reject(msg);\n\t\t\t\t};\n\t\t\t\timg.src = URL + \"/api/v1/images/\" + id + \"/file\";\n\t\t\t}\n\n\t\t\treturn deferred.promise;\n\t\t};\n\n\t\t/**\n\t\t * Initializes the service for a given transect. Returns a promise that\n\t\t * is resolved, when the service is initialized.\n\t\t */\n\t\tthis.init = function (transectId) {\n\t\t\timageIds = TransectImage.query({transect_id: transectId});\n\t\t\t\n\t\t\treturn imageIds.$promise;\n\t\t};\n\n\t\t/**\n\t\t * Show the image with the specified ID. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.show = function (id) {\n\t\t\tvar promise = fetchImage(id).then(function() {\n\t\t\t\tshow(id);\n\t\t\t});\n\n\t\t\t// wait for imageIds to be loaded\n\t\t\timageIds.$promise.then(function () {\n\t\t\t\t// pre-load previous and next images but don't display them\n\t\t\t\tfetchImage(nextId(id));\n\t\t\t\tfetchImage(prevId(id));\n\t\t\t});\n\n\t\t\treturn promise;\n\t\t};\n\n\t\t/**\n\t\t * Show the next image. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.next = function () {\n\t\t\treturn _this.show(nextId());\n\t\t};\n\n\t\t/**\n\t\t * Show the previous image. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.prev = function () {\n\t\t\treturn _this.show(prevId());\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name urlParams\n * @memberOf dias.annotations\n * @description The GET parameters of the url.\n */\nangular.module('dias.annotations').service('urlParams', function () {\n\t\t\"use strict\";\n\n\t\tvar state = {};\n\t\tvar slug = '';\n\n\t\tvar decodeState = function () {\n\t\t\tvar params = location.hash.replace('#', '')\n\t\t\t                          .split('&');\n\n\t\t\tvar state = {};\n\n\t\t\tparams.forEach(function (param) {\n\t\t\t\t// capture key-value pairs\n\t\t\t\tvar capture = param.match(/(.+)\\=(.+)/);\n\t\t\t\tif (capture && capture.length === 3) {\n\t\t\t\t\tstate[capture[1]] = decodeURIComponent(capture[2]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn state;\n\t\t};\n\n\t\tvar encodeState = function (state) {\n\t\t\tvar params = '';\n\t\t\tfor (var key in state) {\n\t\t\t\tparams += key + '=' + encodeURIComponent(state[key]) + '&';\n\t\t\t}\n\t\t\treturn params.substring(0, params.length - 1);\n\t\t};\n\n\t\tthis.pushState = function (s) {\n\t\t\tslug = s;\n\t\t\thistory.pushState(state, '', slug + '#' + encodeState(state));\n\t\t};\n\n\t\tthis.set = function (params) {\n\t\t\tfor (var key in params) {\n\t\t\t\tstate[key] = params[key];\n\t\t\t}\n\t\t\thistory.replaceState(state, '', slug + '#' + encodeState(state));\n\t\t};\n\n\t\tthis.get = function (key) {\n\t\t\treturn state[key];\n\t\t};\n\n\t\tstate = history.state;\n\n\t\tif (!state) {\n\t\t\tstate = decodeState();\n\t\t}\n\t}\n);"],"sourceRoot":"/source/"}