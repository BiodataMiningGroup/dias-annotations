{"version":3,"sources":["annotations/main.js","annotations/controllers/AnnotatorController.js","annotations/controllers/CanvasController.js","annotations/controllers/SVGController.js","annotations/services/images.js","annotations/services/urlParams.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["/**\n * @namespace dias.annotations\n * @description The DIAS annotations module.\n */\nangular.module('dias.annotations', ['dias.api']);\n","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name AnnotatorController\n * @memberOf dias.annotations\n * @description Main controller of the Annotator application.\n */\nangular.module('dias.annotations').controller('AnnotatorController', function ($scope, $attrs, images, urlParams) {\n\t\t\"use strict\";\n\n\t\t$scope.images = images;\n\t\t$scope.imageLoading = true;\n\n\t\t// state of the svg\n\t\t$scope.svg = {\n\t\t\t// the current scale of the elements\n\t\t\tscale: urlParams.get('s') || 1,\n\t\t\t// the current translation (position) of the elements\n\t\t\t// the values are stored negated to save the '-' in the URL\n\t\t\t// (because they are always/mostly negative)\n\t\t\ttranslateX: -urlParams.get('x') || 0,\n\t\t\ttranslateY: -urlParams.get('y') || 0,\n\t\t\t// mouse position taking zooming and translating into account\n\t\t\tmouseX: 0,\n\t\t\tmouseY: 0\n\t\t};\n\n\t\tvar finishLoading = function () {\n\t\t\t$scope.imageLoading = false;\n\t\t\turlParams.pushState($scope.images.currentImage._id);\n\t\t};\n\n\t\tvar startLoading = function () {\n\t\t\t$scope.imageLoading = true;\n\t\t};\n\n\t\t$scope.nextImage = function () {\n\t\t\tstartLoading();\n\t\t\timages.next().then(finishLoading);\n\t\t};\n\n\t\t$scope.prevImage = function () {\n\t\t\tstartLoading();\n\t\t\timages.prev().then(finishLoading);\n\t\t};\n\n\t\t$scope.$watch('svg.scale', function (scale) {\n\t\t\t// scaling affects translate as well\n\t\t\turlParams.set({\n\t\t\t\ts: scale,\n\t\t\t\t// make sure to store the negated values\n\t\t\t\tx: -$scope.svg.translateX,\n\t\t\t\ty: -$scope.svg.translateY\n\t\t\t});\n\t\t});\n\n\t\t$scope.$on('svg.panning.stop', function () {\n\t\t\turlParams.set({\n\t\t\t\t// make sure to store the negated values\n\t\t\t\tx: -$scope.svg.translateX,\n\t\t\t\ty: -$scope.svg.translateY\n\t\t\t});\n\t\t});\n\n\t\timages.init($attrs.transectId);\n\t\timages.show(parseInt($attrs.imageId)).then(finishLoading);\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name CanvasController\n * @memberOf dias.annotations\n * @description Main controller for the annotation canvas element\n */\nangular.module('dias.annotations').controller('CanvasController', function ($scope, $element) {\n\t\t\"use strict\";\n\n\t\tvar offsetTop = 0;\n\n\t\t// the current mouse position relative to the canvas container\n\t\t$scope.mouseX = 0;\n\t\t$scope.mouseY = 0;\n\n\t\t// the dimensions of the canvas container\n\t\tvar updateDimensions = function () {\n\t\t\t$scope.width = $element[0].offsetWidth;\n\t\t\t$scope.height = $element[0].offsetHeight;\n\t\t};\n\n\t\tupdateDimensions();\n\n\t\twindow.addEventListener('resize', function () {\n\t\t\t$scope.$apply(updateDimensions);\n\t\t});\n\n\t\t$scope.updateMouse = function (e) {\n\t\t\t$scope.mouseX = e.clientX;\n\t\t\t$scope.mouseY = e.clientY - offsetTop;\n\t\t};\n\n\t\tvar updateOffset = function () {\n\t\t\toffsetTop = $element[0].offsetTop;\n\t\t};\n\n\t\tupdateOffset();\n\n\t\twindow.addEventListener('resize', updateOffset);\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc controller\n * @name SVGController\n * @memberOf dias.annotations\n * @description Controller for the annotation canvas SVG element handling\n * the zooming and panning etc.\n */\nangular.module('dias.annotations').controller('SVGController', function ($scope, $element) {\n\t\t\"use strict\";\n\n\t\t// the scale change per scaling operation\n\t\tvar scaleStep = 0.05;\n\t\t// the minimal scale\n\t\tvar minScale = 1;\n\t\t// translate values when panning starts\n\t\tvar panningStartTranslateX = 0;\n\t\tvar panningStartTranslateY = 0;\n\t\t// mouse position when panning starts\n\t\tvar panningStartMouseX = 0;\n\t\tvar panningStartMouseY = 0;\n\n\t\t// the inherited svg state object\n\t\tvar svg = $scope.svg;\n\n\t\t// is the user currently panning?\n\t\t$scope.panning = false;\n\n\t\t// makes sure the translate boundaries are kept\n\t\tvar updateTranslate = function (translateX, translateY) {\n\t\t\t// scaleFactor for the right/bottom edge\n\t\t\tvar scaleFactor = 1 - svg.scale;\n\t\t\t// right\n\t\t\ttranslateX = Math.max(translateX, $scope.width * scaleFactor);\n\t\t\t// bottom\n\t\t\ttranslateY = Math.max(translateY, $scope.height * scaleFactor);\n\t\t\t// left\n\t\t\ttranslateX = Math.min(translateX, 0);\n\t\t\t// top\n\t\t\ttranslateY = Math.min(translateY, 0);\n\n\t\t\tsvg.translateX = Math.round(translateX);\n\t\t\tsvg.translateY = Math.round(translateY);\n\t\t};\n\n\t\t// scale towards the cursor\n\t\t// see http://stackoverflow.com/a/20996105/1796523\n\t\tvar updateScaleTranslate = function (scale, oldScale) {\n\t\t\tvar scaleDifference = scale / oldScale;\n\n\t\t\tvar translateX = scaleDifference * (svg.translateX - $scope.mouseX) + $scope.mouseX;\n\t\t\tvar translateY = scaleDifference * (svg.translateY - $scope.mouseY) + $scope.mouseY;\n\n\t\t\tupdateTranslate(translateX, translateY);\n\t\t};\n\n\t\t$scope.$watch('svg.scale', updateScaleTranslate);\n\n\t\tvar updateMouseX = function (mouseX) {\n\t\t\tsvg.mouseX = (mouseX - svg.translateX) / svg.scale;\n\t\t};\n\n\t\t$scope.$watch('mouseX', updateMouseX);\n\n\t\tvar updateMouseY = function (mouseY) {\n\t\t\tsvg.mouseY = (mouseY - svg.translateY) / svg.scale;\n\t\t};\n\n\t\t$scope.$watch('mouseY', updateMouseY);\n\n\t\tvar zoom = function (e) {\n\t\t\tvar scale = svg.scale - scaleStep * e.deltaY;\n\t\t\tscale = Math.round(scale * 1000) / 1000;\n\t\t\tsvg.scale = Math.max(scale, minScale);\n\t\t\te.preventDefault();\n\t\t};\n\n\t\t$element.on('wheel', function (e) {\n\t\t\t$scope.$apply(function () { zoom(e); });\n\t\t});\n\n\t\t$scope.startPanning = function (event) {\n\t\t\t$scope.panning = true;\n\t\t\tpanningStartTranslateX = svg.translateX;\n\t\t\tpanningStartTranslateY = svg.translateY;\n\t\t\tpanningStartMouseX = $scope.mouseX;\n\t\t\tpanningStartMouseY = $scope.mouseY;\n\n\t\t\t// prevent default drag & drop behaviour for images\n\t\t\tevent.preventDefault();\n\t\t\t$scope.$emit('svg.panning.start');\n\t\t};\n\n\t\t$scope.pan = function () {\n\t\t\tif (!$scope.panning) return;\n\n\t\t\tvar translateX = panningStartTranslateX - (panningStartMouseX - $scope.mouseX);\n\t\t\tvar translateY = panningStartTranslateY - (panningStartMouseY - $scope.mouseY);\n\n\t\t\tupdateTranslate(translateX, translateY);\n\t\t};\n\n\t\t$scope.stopPanning = function () {\n\t\t\t$scope.panning = false;\n\t\t\t$scope.$emit('svg.panning.stop');\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name images\n * @memberOf dias.annotations\n * @description Manages (pre-)loading of the images to annotate.\n */\nangular.module('dias.annotations').service('images', function (TransectImage, URL, $q) {\n\t\t\"use strict\";\n\n\t\tvar _this = this;\n\t\t// array of all image IDs of the transect\n\t\tvar imageIds = [];\n\t\t// maximum number of images to hold in buffer\n\t\tvar MAX_BUFFER_SIZE = 10;\n\t\t// buffer of already loaded images\n\t\tvar buffer = [];\n\n\t\t// the currently shown image\n\t\tthis.currentImage = undefined;\n\n\t\t/**\n\t\t * Returns the next ID of the specified image or the next ID of the \n\t\t * current image if no image was specified.\n\t\t */\n\t\tvar nextId = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tvar index = imageIds.indexOf(id);\n\t\t\treturn imageIds[(index + 1) % imageIds.length];\n\t\t};\n\n\t\t/**\n\t\t * Returns the previous ID of the specified image or the previous ID of\n\t\t * the current image if no image was specified.\n\t\t */\n\t\tvar prevId = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tvar index = imageIds.indexOf(id);\n\t\t\tvar length = imageIds.length;\n\t\t\treturn imageIds[(index - 1 + length) % length];\n\t\t};\n\n\t\t/**\n\t\t * Returns the specified image from the buffer or `undefined` if it is\n\t\t * not buffered.\n\t\t */\n\t\tvar getImage = function (id) {\n\t\t\tid = id || _this.currentImage._id;\n\t\t\tfor (var i = buffer.length - 1; i >= 0; i--) {\n\t\t\t\tif (buffer[i]._id == id) return buffer[i];\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t};\n\n\t\t/**\n\t\t * Sets the specified image to as the currently shown image.\n\t\t */\n\t\tvar show = function (id) {\n\t\t\t_this.currentImage = getImage(id);\n\t\t};\n\n\t\t/**\n\t\t * Loads the specified image either from buffer or from the external \n\t\t * resource. Returns a promise that gets resolved when the image is\n\t\t * loaded.\n\t\t */\n\t\tvar fetchImage = function (id) {\n\t\t\tvar deferred = $q.defer();\n\t\t\tvar img = getImage(id);\n\n\t\t\tif (img) {\n\t\t\t\tdeferred.resolve(img);\n\t\t\t} else {\n\t\t\t\timg = document.createElement('img');\n\t\t\t\timg._id = id;\n\t\t\t\timg.onload = function () {\n\t\t\t\t\tbuffer.push(img);\n\t\t\t\t\t// control maximum buffer size\n\t\t\t\t\tif (buffer.length > MAX_BUFFER_SIZE) {\n\t\t\t\t\t\tbuffer.shift();\n\t\t\t\t\t}\n\t\t\t\t\tdeferred.resolve(img);\n\t\t\t\t};\n\t\t\t\timg.onerror = function (msg) {\n\t\t\t\t\tdeferred.reject(msg);\n\t\t\t\t};\n\t\t\t\timg.src = URL + \"/api/v1/images/\" + id + \"/file\";\n\t\t\t}\n\n\t\t\treturn deferred.promise;\n\t\t};\n\n\t\t/**\n\t\t * Initializes the service for a given transect. Returns a promise that\n\t\t * is resolved, when the service is initialized.\n\t\t */\n\t\tthis.init = function (transectId) {\n\t\t\timageIds = TransectImage.query({transect_id: transectId});\n\t\t\t\n\t\t\treturn imageIds.$promise;\n\t\t};\n\n\t\t/**\n\t\t * Show the image with the specified ID. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.show = function (id) {\n\t\t\tvar promise = fetchImage(id).then(function() {\n\t\t\t\tshow(id);\n\t\t\t});\n\n\t\t\t// wait for imageIds to be loaded\n\t\t\timageIds.$promise.then(function () {\n\t\t\t\t// pre-load previous and next images but don't display them\n\t\t\t\tfetchImage(nextId(id));\n\t\t\t\tfetchImage(prevId(id));\n\t\t\t});\n\n\t\t\treturn promise;\n\t\t};\n\n\t\t/**\n\t\t * Show the next image. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.next = function () {\n\t\t\treturn _this.show(nextId());\n\t\t};\n\n\t\t/**\n\t\t * Show the previous image. Returns a promise that is\n\t\t * resolved when the image is shown.\n\t\t */\n\t\tthis.prev = function () {\n\t\t\treturn _this.show(prevId());\n\t\t};\n\t}\n);","/**\n * @namespace dias.annotations\n * @ngdoc service\n * @name urlParams\n * @memberOf dias.annotations\n * @description The GET parameters of the url.\n */\nangular.module('dias.annotations').service('urlParams', function () {\n\t\t\"use strict\";\n\n\t\tvar state = {};\n\t\tvar slug = '';\n\n\t\tvar decodeState = function () {\n\t\t\tvar params = location.hash.replace('#', '')\n\t\t\t                          .split('&');\n\n\t\t\tvar state = {};\n\n\t\t\tparams.forEach(function (param) {\n\t\t\t\t// capture key-value pairs\n\t\t\t\tvar capture = param.match(/(.+)\\=(.+)/);\n\t\t\t\tif (capture && capture.length === 3) {\n\t\t\t\t\tstate[capture[1]] = decodeURIComponent(capture[2]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn state;\n\t\t};\n\n\t\tvar encodeState = function (state) {\n\t\t\tvar params = '';\n\t\t\tfor (var key in state) {\n\t\t\t\tparams += key + '=' + encodeURIComponent(state[key]) + '&';\n\t\t\t}\n\t\t\treturn params.substring(0, params.length - 1);\n\t\t};\n\n\t\tthis.pushState = function (s) {\n\t\t\tslug = s;\n\t\t\thistory.pushState(state, '', slug + '#' + encodeState(state));\n\t\t};\n\n\t\tthis.set = function (params) {\n\t\t\tfor (var key in params) {\n\t\t\t\tstate[key] = params[key];\n\t\t\t}\n\t\t\thistory.replaceState(state, '', slug + '#' + encodeState(state));\n\t\t};\n\n\t\tthis.get = function (key) {\n\t\t\treturn state[key];\n\t\t};\n\n\t\tstate = history.state;\n\n\t\tif (!state) {\n\t\t\tstate = decodeState();\n\t\t}\n\t}\n);"],"sourceRoot":"/source/"}